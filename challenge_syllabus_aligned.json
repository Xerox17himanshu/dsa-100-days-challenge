[
  {
    "day": 1,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Insert an Element in an Array",
      "description": "Problem: Write a C program to insert an element x at a given 1-based position pos in an array of n integers. Shift existing elements to the right to make space.\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers (the array)\n- Third line: integer pos (1-based position)\n- Fourth line: integer x (element to insert)\n\nOutput:\n- Print the updated array (n+1 integers) in a single line, space-separated\n\nExample:\nInput:\n5\n1 2 4 5 6\n3\n3\n\nOutput:\n1 2 3 4 5 6\n\nExplanation: Insert 3 at position 3, elements [4,5,6] shift right"
    },
    "question2": {
      "name": "Two Sum",
      "link": "https://leetcode.com/problems/two-sum/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Basics",
      "Hash Tables"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "To insert an element at a specific position in an array:\n\n1. Shift all elements from position 'pos' to the end, one step to the right\n2. Insert the new element at the specified position\n3. The array size increases by 1\n\nKey Points:\n- Start shifting from the end to avoid overwriting values\n- Position is 1-based, but array indexing is 0-based\n- Ensure the array has enough space",
          "code": "#include <stdio.h>\n\nint main() {\n    int n, pos, x;\n    int arr[101];\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    scanf(\"%d %d\", &pos, &x);\n\n    for (int i = n; i >= pos; i--) {\n        arr[i] = arr[i - 1];\n    }\n\n    arr[pos - 1] = x;\n\n    for (int i = 0; i <= n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "Solution Article",
          "link": "https://yourblog.com/day1-insert-element-solution"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "NeetCode Explanation",
          "link": "https://www.youtube.com/watch?v=KLlXCFG5TnA"
        },
             {
        "explanation": "Find two numbers that add up to target using a brute-force approach.\n\nApproach:\n1. Use two nested loops to check all possible pairs\n2. Fix the first number using the outer loop\n3. For each fixed number, check the remaining numbers using the inner loop\n4. If nums[i] + nums[j] equals target, return their indices\n\nWhy it works:\n- All possible pairs are checked\n- No extra data structure is used\n- Guaranteed to find the correct pair if it exists",
        "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n        return {};\n    }\n};",
        "timeComplexity": "O(n^2)",
        "spaceComplexity": "O(1)",
        "type": "tutorial"
      }
      ]
    }
  },
  {
    "day": 2,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Delete an Element from an Array",
      "description": "Problem: Write a C program to delete the element at a given 1-based position pos from an array of n integers. Shift remaining elements to the left.\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers\n- Third line: integer pos (1-based position to delete)\n\nOutput:\n- Print the updated array with (n-1) elements, space-separated\n\nExample:\nInput:\n5\n10 20 30 40 50\n2\n\nOutput:\n10 30 40 50\n\nExplanation: Delete position 2 (element 20), remaining elements shift left"
    },
    "question2": {
      "name": "Best Time to Buy and Sell Stock",
      "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Operations",
      "Math"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "To delete an element from an array at a given position:\n\n1. Shift all elements after position 'pos' one step to the left\n2. This overwrites the element to be deleted\n3. Reduce the array size by 1\n\nKey Points:\n- Start shifting from the deletion position forward\n- No need to clear the last element (it's now outside array bounds)\n- Position is 1-based for input, but array uses 0-based indexing",
          "code": "#include <stdio.h>\n\nint main() {\n    int n, pos;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    scanf(\"%d\", &pos);\n    \n    // Shift elements left\n    for (int i = pos - 1; i < n - 1; i++) {\n        arr[i] = arr[i + 1];\n    }\n    \n    for (int i = 0; i < n - 1; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 2) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "Solution Walkthrough",
          "link": "https://yourblog.com/day2-delete-element-solution"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Video Tutorial",
          "link": "https://www.youtube.com/watch?v=1pkOgXD63yU"
        },
        {
          "type": "tutorial",
          "explanation": "Find maximum profit from buying and selling stock once.\n\nAlgorithm:\n1. Track minimum price seen so far\n2. For each price, calculate profit if selling today\n3. Update maximum profit\n\nKey Insight:\n- Buy at lowest price before current day\n- Sell at current price for maximum profit\n- One pass solution",
          "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int minPrice = INT_MAX;\n        int maxProfit = 0;\n        \n        for (int price : prices) {\n            minPrice = min(minPrice, price);\n            maxProfit = max(maxProfit, price - minPrice);\n        }\n        \n        return maxProfit;\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "LeetCode Editorial",
          "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/editorial/"
        }
      ]
    }
  },
  {
    "day": 3,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Linear Search with Comparison Count",
      "description": "Problem: Implement linear search to find key k in an array. Count and display the number of comparisons performed.\n\nInput:\n- First line: integer n (array size)\n- Second line: n space-separated integers\n- Third line: integer k (key to search)\n\nOutput:\n- Line 1: \"Found at index i\" OR \"Not Found\"\nLine 2: \"Comparisons = c\"\n\nExample:\nInput:\n5\n10 20 30 40 50\n30\n\nOutput:\nFound at index 2\nComparisons = 3\n\nExplanation: Compared with 10, 20, 30 (found at index 2 with 3 comparisons)"
    },
    "question2": {
      "name": "Missing number in array",
      "link": "https://practice.geeksforgeeks.org/problems/missing-number-in-array/0",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Searching"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Linear search checks each element sequentially until finding the target or reaching the end.\n\nAlgorithm:\n1. Iterate through each element of the array\n2. Compare current element with the search key\n3. If found, return the index\n4. If not found after checking all elements, return -1\n\nKey Points:\n- Works on unsorted arrays\n- Time complexity is O(n) in worst case\n- Count comparisons to analyze performance",
          "code": "#include <stdio.h>\n\nint main() {\n    int n, k, comparisons = 0;\n    int arr[100];\n    int found = -1;\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    scanf(\"%d\", &k);\n    \n    for (int i = 0; i < n; i++) {\n        comparisons++;\n        if (arr[i] == k) {\n            found = i;\n            break;\n        }\n    }\n    \n    if (found != -1) {\n        printf(\"Found at index %d\\n\", found);\n    } else {\n        printf(\"Not Found\\n\");\n    }\n    printf(\"Comparisons = %d\\n\", comparisons);\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "Algorithm Explanation",
          "link": "https://yourblog.com/day3-linear-search-solution"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "GFG Video Solution",
          "link": "https://www.youtube.com/watch?v=WnPLSRLSANE"
        },
        {
          "type": "tutorial",
          "explanation": "Find missing number using sum formula or XOR.\n\nApproach 1 - Sum Formula:\n1. Calculate expected sum: n*(n+1)/2\n2. Calculate actual sum\n3. Difference is missing number\n\nApproach 2 - XOR:\n1. XOR all indices with all array values\n2. Pairs cancel out, leaving missing number",
          "code": "class Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int n = nums.size();\n        int expectedSum = n * (n + 1) / 2;\n        int actualSum = 0;\n        \n        for (int num : nums) {\n            actualSum += num;\n        }\n        \n        return expectedSum - actualSum;\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "GeeksforGeeks Article",
          "link": "https://www.geeksforgeeks.org/find-the-missing-number/"
        }
      ]
    }
  },
  {
    "day": 4,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Reverse an Array In-Place",
      "description": "Problem: Given an array of n integers, reverse the array in-place using two-pointer approach.\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers\n\nOutput:\n- Print the reversed array, space-separated\n\nExample:\nInput:\n5\n1 2 3 4 5\n\nOutput:\n5 4 3 2 1\n\nExplanation: Swap pairs from both ends: (1,5), (2,4), middle 3 stays"
    },
    "question2": {
      "name": "Remove Element",
      "link": "https://leetcode.com/problems/remove-element/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Reversal",
      "Two Pointers"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Reverse an array using the two-pointer technique:\n\n1. Use two pointers: one at start (left) and one at end (right)\n2. Swap elements at left and right pointers\n3. Move left pointer forward and right pointer backward\n4. Continue until left >= right\n\nKey Points:\n- In-place reversal (no extra array needed)\n- Efficient with O(n/2) swaps\n- Works for arrays of any size",
          "code": "#include <stdio.h>\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    // Two-pointer reversal\n    int left = 0, right = n - 1;\n    while (left < right) {\n        int temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left++;\n        right--;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "Two-Pointer Approach",
          "link": "https://yourblog.com/day4-reverse-array-solution"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Video Explanation",
          "link": "https://www.youtube.com/watch?v=Pcd1ii9P9ZI"
        },
        {
          "type": "tutorial",
          "explanation": "Remove all instances of val in-place using two pointers.\n\nApproach:\n1. Use slow pointer to track position to write\n2. Fast pointer scans through array\n3. Copy non-val elements to slow pointer position\n4. Return new length\n\nKey Points:\n- In-place modification\n- Order of elements can change\n- Return new array length",
          "code": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int slow = 0;\n        \n        for (int fast = 0; fast < nums.size(); fast++) {\n            if (nums[fast] != val) {\n                nums[slow] = nums[fast];\n                slow++;\n            }\n        }\n        \n        return slow;\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        },
        {
          "type": "editorial",
          "label": "LeetCode Editorial",
          "link": "https://leetcode.com/problems/remove-element/editorial/"
        }
      ]
    }
  },
  {
    "day": 5,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Arrange Arrival Logs",
      "description": "Problem: A system receives two separate logs of user arrival times from two different servers. Each log is already sorted in ascending order. Your task is to create a single chronological log that preserves the correct order of arrivals.\n\nInput:\n- First line: integer p (number of entries in server log 1)\n- Second line: p sorted integers representing arrival times from server 1\n- Third line: integer q (number of entries in server log 2)\n- Fourth line: q sorted integers representing arrival times from server 2)\n\nOutput:\n- Print a single line containing all arrival times in chronological order, separated by spaces\n\nExample:\nInput:\n5\n10 20 30 50 70\n4\n15 25 40 60\n\nOutput:\n10 15 20 25 30 40 50 60 70\n\nExplanation: Compare the next unprocessed arrival time from both logs and append the earlier one to the final log until all entries are processed"
    },
    "question2": {
      "name": "Merge Sorted Array",
      "link": "https://leetcode.com/problems/merge-sorted-array/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Merge",
      "Two Pointers"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Merge two sorted arrays using two-pointer technique:\n\n1. Use pointers i and j for array1 and array2\n2. Compare elements at both pointers\n3. Add smaller element to result and move that pointer\n4. When one array is exhausted, copy remaining elements from other array\n\nKey Points:\n- Maintains sorted order\n- Time complexity O(n + m)\n- Requires extra space for result array",
          "code": "#include <stdio.h>\n\nint main() {\n    int n1, n2;\n    int arr1[100], arr2[100], result[200];\n    \n    scanf(\"%d\", &n1);\n    for (int i = 0; i < n1; i++) {\n        scanf(\"%d\", &arr1[i]);\n    }\n    \n    scanf(\"%d\", &n2);\n    for (int i = 0; i < n2; i++) {\n        scanf(\"%d\", &arr2[i]);\n    }\n    \n    int i = 0, j = 0, k = 0;\n    while (i < n1 && j < n2) {\n        if (arr1[i] <= arr2[j]) {\n            result[k++] = arr1[i++];\n        } else {\n            result[k++] = arr2[j++];\n        }\n    }\n    \n    while (i < n1) result[k++] = arr1[i++];\n    while (j < n2) result[k++] = arr2[j++];\n    \n    for (int i = 0; i < k; i++) {\n        printf(\"%d\", result[i]);\n        if (i < k - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n + m)",
          "spaceComplexity": "O(n + m)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "LeetCode Video",
          "link": "https://www.youtube.com/watch?v=P1Ic85RarKY"
        },
        {
          "type": "tutorial",
          "explanation": "Merge nums2 into nums1 (which has enough space) in-place.\n\nApproach:\n1. Start from the end of both arrays\n2. Compare elements and place larger one at end of nums1\n3. Move pointers backward\n4. Copy remaining elements from nums2 if any\n\nKey Points:\n- Work backwards to avoid overwriting\n- nums1 has space for both arrays\n- In-place solution",
          "code": "class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int i = m - 1, j = n - 1, k = m + n - 1;\n        \n        while (i >= 0 && j >= 0) {\n            if (nums1[i] > nums2[j]) {\n                nums1[k--] = nums1[i--];\n            } else {\n                nums1[k--] = nums2[j--];\n            }\n        }\n        \n        while (j >= 0) {\n            nums1[k--] = nums2[j--];\n        }\n    }\n};",
          "timeComplexity": "O(n + m)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 6,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Remove Duplicates from Sorted Array",
      "description": "Problem: Given a sorted array of n integers, remove duplicates in-place. Print only unique elements in order.\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers (sorted array)\n\nOutput:\n- Print unique elements only, space-separated\n\nExample:\nInput:\n6\n1 1 2 2 3 3\n\nOutput:\n1 2 3\n\nExplanation: Keep first occurrence of each element: 1, 2, 3"
    },
    "question2": {
      "name": "Move Zeroes",
      "link": "https://leetcode.com/problems/move-zeroes/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Cleanup"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Remove duplicates from sorted array using two pointers:\n\n1. Use slow pointer to track position of unique elements\n2. Fast pointer scans through array\n3. When different element found, copy to slow+1 position\n4. Return count of unique elements\n\nKey Points:\n- Array is sorted, duplicates are adjacent\n- First element is always unique\n- In-place modification",
          "code": "#include <stdio.h>\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    int slow = 0;\n    for (int fast = 1; fast < n; fast++) {\n        if (arr[fast] != arr[slow]) {\n            slow++;\n            arr[slow] = arr[fast];\n        }\n    }\n    \n    for (int i = 0; i <= slow; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < slow) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Move Zeroes - Video Solution",
          "link": "https://www.youtube.com/watch?v=aayNRwUN3Do"
        },
        {
          "type": "tutorial",
          "explanation": "Move all zeroes to end while maintaining relative order of non-zero elements.\n\nApproach:\n1. Use slow pointer for non-zero position\n2. Fast pointer scans array\n3. Swap non-zero elements to front\n4. Zeroes automatically move to end\n\nKey Points:\n- In-place modification\n- Maintain relative order\n- Two-pointer technique",
          "code": "class Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int slow = 0;\n        \n        for (int fast = 0; fast < nums.size(); fast++) {\n            if (nums[fast] != 0) {\n                swap(nums[slow], nums[fast]);\n                slow++;\n            }\n        }\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 7,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Recursive Fibonacci",
      "description": "Problem: Write a recursive function fib(n) to compute the n-th Fibonacci number where fib(0)=0 and fib(1)=1.\n\nInput:\n- Single integer n\n\nOutput:\n- Print the n-th Fibonacci number\n\nExample:\nInput:\n6\n\nOutput:\n8\n\nExplanation: Sequence: 0,1,1,2,3,5,8 at positions 0,1,2,3,4,5,6"
    },
    "question2": {
      "name": "Fibonacci Number",
      "link": "https://leetcode.com/problems/fibonacci-number/",
      "difficulty": "Easy"
    },
    "topics": [
      "Recursion"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Recursive solution for Fibonacci:\n\n1. Define base cases: fib(0) = 0, fib(1) = 1\n2. Recursive case: fib(n) = fib(n-1) + fib(n-2)\n3. Ensure progress toward base case\n\nKey Points:\n- Recursion uses call stack\n- Watch for stack overflow with large inputs\n- Consider iterative alternative for better space complexity\n- Can use memoization to optimize",
          "code": "#include <stdio.h>\n\nint fib(int n) {\n    // Base cases\n    if (n <= 1) return n;\n    \n    // Recursive case\n    return fib(n - 1) + fib(n - 2);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    printf(\"%d\\n\", fib(n));\n    return 0;\n}",
          "timeComplexity": "O(2^n)",
          "spaceComplexity": "O(n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Fibonacci Number - Video Solution",
          "link": "https://www.youtube.com/watch?v=3lpNp5Ojvrw"
        },
        {
          "type": "tutorial",
          "explanation": "Calculate Fibonacci number efficiently.\n\nApproach 1 - Iterative (Optimal):\n1. Use two variables to track previous two numbers\n2. Iterate from 2 to n\n3. Update variables in each iteration\n\nApproach 2 - Recursive with Memoization:\n1. Cache computed values\n2. Avoid redundant calculations\n\nKey Points:\n- Iterative is O(n) time, O(1) space\n- Recursive is simpler but less efficient",
          "code": "class Solution {\npublic:\n    int fib(int n) {\n        if (n <= 1) return n;\n        \n        int prev2 = 0, prev1 = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            int curr = prev1 + prev2;\n            prev2 = prev1;\n            prev1 = curr;\n        }\n        \n        return prev1;\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 8,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Compute Power Using Recursion",
      "description": "Problem: Given integers a and b, compute a^b using recursion without using pow() function.\n\nInput:\n- Two space-separated integers a and b\n\nOutput:\n- Print a raised to power b\n\nExample:\nInput:\n2 5\n\nOutput:\n32\n\nExplanation: 2^5 = 2 * 2 * 2 * 2 * 2 = 32"
    },
    "question2": {
      "name": "Power of Two",
      "link": "https://leetcode.com/problems/power-of-two/",
      "difficulty": "Easy"
    },
    "topics": [
      "Recursion",
      "Math"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Compute power using recursion:\n\n1. Base case: a^0 = 1\n2. Recursive case: a^b = a * a^(b-1)\n3. Can optimize with divide and conquer for O(log n)\n\nKey Points:\n- Simple recursion is O(b) time\n- Fast exponentiation uses a^(2k) = (a^k)^2\n- Handle negative exponents if needed",
          "code": "#include <stdio.h>\n\nint power(int a, int b) {\n    // Base case\n    if (b == 0) return 1;\n    \n    // Recursive case\n    return a * power(a, b - 1);\n}\n\nint main() {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    printf(\"%d\\n\", power(a, b));\n    return 0;\n}",
          "timeComplexity": "O(b)",
          "spaceComplexity": "O(b)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Power of Two - Video Solution",
          "link": "https://www.youtube.com/watch?v=H2bjttEV4Vc"
        },
        {
          "type": "tutorial",
          "explanation": "Check if n is a power of 2.\n\nApproach 1 - Bit Manipulation:\n1. Power of 2 has exactly one bit set\n2. Use n & (n-1) == 0 trick\n3. Also check n > 0\n\nApproach 2 - Recursive Division:\n1. Keep dividing by 2\n2. Check if remainder is 0\n3. Final result should be 1\n\nKey Points:\n- Bit manipulation is O(1)\n- Powers of 2: 1, 2, 4, 8, 16, ...",
          "code": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        if (n <= 0) return false;\n        return (n & (n - 1)) == 0;\n    }\n};",
          "timeComplexity": "O(1)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 9,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Mirror the Code Name",
      "description": "Problem: A secret system stores code names in forward order. To display them in mirror format, you must transform the given code name so that its characters appear in the opposite order.\n\nInput:\n- Single line: a lowercase string containing only alphabetic characters (no spaces)\n\nOutput:\n- Print the transformed code name after applying the mirror operation\n\nExample:\nInput:\nhello\n\nOutput:\nolleh\n\nExplanation: The first character moves to the last position, the second to the second-last, and so on until the entire string is mirrored"
    },
    "question2": {
      "name": "Reverse String",
      "link": "https://leetcode.com/problems/reverse-string/",
      "difficulty": "Easy"
    },
    "topics": [
      "String",
      "Two Pointers"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Reverse a string using two-pointer technique:\n\n1. Use two pointers: one at start, one at end\n2. Swap characters at both pointers\n3. Move pointers toward center\n4. Stop when pointers meet\n\nKey Points:\n- In-place reversal\n- Works for strings of any length\n- O(n/2) swaps needed",
          "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[1000];\n    scanf(\"%s\", str);\n    \n    int left = 0;\n    int right = strlen(str) - 1;\n    \n    while (left < right) {\n        char temp = str[left];\n        str[left] = str[right];\n        str[right] = temp;\n        left++;\n        right--;\n    }\n    \n    printf(\"%s\\n\", str);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Reverse String - Video Solution",
          "link": "https://www.youtube.com/watch?v=_d0T_2Lk2qA"
        },
        {
          "type": "tutorial",
          "explanation": "Reverse string in-place (array of characters).\n\nApproach:\n1. Use two pointers from both ends\n2. Swap characters\n3. Move pointers toward center\n4. Must modify input array directly\n\nKey Points:\n- In-place requirement (O(1) space)\n- Two-pointer technique\n- Return void, modify input",
          "code": "class Solution {\npublic:\n    void reverseString(vector<char>& s) {\n        int left = 0, right = s.size() - 1;\n        \n        while (left < right) {\n            swap(s[left], s[right]);\n            left++;\n            right--;\n        }\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 10,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Check Palindrome",
      "description": "Problem: Read a string and check if it is a palindrome using two-pointer comparison.\n\nInput:\n- Single line: string s\n\nOutput:\n- Print YES if palindrome, otherwise NO\n\nExample:\nInput:\nlevel\n\nOutput:\nYES\n\nExplanation: String reads same forwards and backwards"
    },
    "question2": {
      "name": "Intersection of two arrays",
      "link": "https://leetcode.com/problems/intersection-of-two-arrays-ii/description/",
      "difficulty": "Easy"
    },
    "topics": [
      "Palindrome Check",
      "Array"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Check if string is palindrome using two pointers:\n\n1. Use left pointer at start, right at end\n2. Compare characters at both positions\n3. If different, not palindrome\n4. Move pointers toward center\n5. If all match, it's palindrome\n\nKey Points:\n- Case-sensitive comparison\n- Works for odd and even length strings\n- Early termination on mismatch",
          "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nint main() {\n    char str[1000];\n    scanf(\"%s\", str);\n    \n    int left = 0;\n    int right = strlen(str) - 1;\n    bool isPalindrome = true;\n    \n    while (left < right) {\n        if (str[left] != str[right]) {\n            isPalindrome = false;\n            break;\n        }\n        left++;\n        right--;\n    }\n    \n    printf(\"%s\\n\", isPalindrome ? \"YES\" : \"NO\");\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Intersection of Two Arrays II - Video",
          "link": "https://www.youtube.com/watch?v=jo7E5K_pJ18"
        },
        {
          "type": "tutorial",
          "explanation": "Find intersection of two arrays (with duplicates).\n\nApproach 1 - Hash Map:\n1. Count frequency of elements in nums1\n2. Iterate through nums2\n3. If element exists in map and count > 0, add to result\n4. Decrement count\n\nApproach 2 - Sorting:\n1. Sort both arrays\n2. Use two pointers\n3. Add common elements\n\nKey Points:\n- Handle duplicates\n- Can appear multiple times in result",
          "code": "class Solution {\npublic:\n    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n        unordered_map<int, int> count;\n        vector<int> result;\n        \n        for (int num : nums1) {\n            count[num]++;\n        }\n        \n        for (int num : nums2) {\n            if (count[num] > 0) {\n                result.push_back(num);\n                count[num]--;\n            }\n        }\n        \n        return result;\n    }\n};",
          "timeComplexity": "O(n + m)",
          "spaceComplexity": "O(min(n, m))"
        }
      ]
    }
  },
  {
    "day": 11,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Matrix Addition",
      "description": "Problem: Write a program to perform addition of two matrices having the same dimensions. The sum of two matrices is obtained by adding corresponding elements of the matrices.\n\nInput:\n- First line: two integers m and n representing the number of rows and columns\n- Next m lines: n integers each representing the elements of the first matrix\n- Next m lines: n integers each representing the elements of the second matrix\n\nOutput:\n- Print the resultant matrix after addition, with each row on a new line and elements separated by spaces\n\nExample:\nInput:\n3 3\n1 2 3\n4 5 6\n7 8 9\n9 8 7\n6 5 4\n3 2 1\n\nOutput:\n10 10 10\n10 10 10\n10 10 10\n\nExplanation:\nEach element of the result matrix is the sum of the corresponding elements from the two input matrices.\n\nTest Cases:\n\nTest Case 1:\nInput:\n2 2\n1 2\n3 4\n5 6\n7 8\nOutput:\n6 8\n10 12\n\nTest Case 2:\nInput:\n1 3\n10 20 30\n1 2 3\nOutput:\n11 22 33\n\nTest Case 3:\nInput:\n3 1\n1\n2\n3\n4\n5\n6\nOutput:\n5\n7\n9"
    },
    "question2": {
      "name": "Transpose Matrix",
      "link": "https://leetcode.com/problems/transpose-matrix/",
      "difficulty": "Easy"
    },
    "topics": [
      "Matrix"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Matrix addition is performed element-wise:\n\n1. Both matrices must have same dimensions (m × n)\n2. Add corresponding elements: result[i][j] = mat1[i][j] + mat2[i][j]\n3. Store in result matrix\n4. Print the result\n\nKey Points:\n- Matrices must have same dimensions\n- Addition is commutative: A + B = B + A\n- Time complexity is O(m × n)",
          "code": "#include <stdio.h>\n\nint main() {\n    int m, n;\n    int mat1[100][100], mat2[100][100], result[100][100];\n    \n    scanf(\"%d %d\", &m, &n);\n    \n    // Read first matrix\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &mat1[i][j]);\n        }\n    }\n    \n    // Read second matrix\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &mat2[i][j]);\n        }\n    }\n    \n    // Add matrices\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            result[i][j] = mat1[i][j] + mat2[i][j];\n        }\n    }\n    \n    // Print result\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            printf(\"%d\", result[i][j]);\n            if (j < n - 1) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}",
          "timeComplexity": "O(m × n)",
          "spaceComplexity": "O(m × n)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Transpose Matrix - Video Solution",
          "link": "https://www.youtube.com/watch?v=hA_yvtCpjsg"
        },
        {
          "type": "tutorial",
          "explanation": "Transpose a matrix (rows become columns).\n\nApproach:\n1. Create result matrix with swapped dimensions\n2. For each element at [i][j], place at [j][i] in result\n3. Return the transposed matrix\n\nKey Points:\n- If input is m × n, output is n × m\n- Element at position (i, j) moves to (j, i)\n- Not in-place for non-square matrices",
          "code": "class Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        \n        vector<vector<int>> result(n, vector<int>(m));\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                result[j][i] = matrix[i][j];\n            }\n        }\n        \n        return result;\n    }\n};",
          "timeComplexity": "O(m × n)",
          "spaceComplexity": "O(m × n)"
        }
      ]
    }
  },
  {
    "day": 12,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Check Symmetric Matrix",
      "description": "Problem: Write a program to check whether a given matrix is symmetric. A matrix is said to be symmetric if it is a square matrix and is equal to its transpose (i.e., element at position [i][j] is equal to element at position [j][i] for all valid i and j).\n\nInput:\n- First line: two integers m and n representing the number of rows and columns\n- Next m lines: n integers each representing the elements of the matrix\n\nOutput:\n- Print \"Symmetric Matrix\" if the given matrix is symmetric\n- Otherwise, print \"Not a Symmetric Matrix\"\n\nExample:\nInput:\n3 3\n1 2 3\n2 4 5\n3 5 6\n\nOutput:\nSymmetric Matrix\n\nExplanation:\nThe matrix is square (3 × 3) and for every i and j, element[i][j] = element[j][i].\n\nTest Cases:\n\nTest Case 1:\nInput:\n2 2\n1 2\n2 1\nOutput:\nSymmetric Matrix\n\nTest Case 2:\nInput:\n3 3\n1 0 1\n2 3 4\n1 4 5\nOutput:\nNot a Symmetric Matrix\n\nTest Case 3:\nInput:\n2 3\n1 2 3\n4 5 6\nOutput:\nNot a Symmetric Matrix"
    },
    "question2": {
      "name": "Toeplitz Matrix",
      "link": "https://leetcode.com/problems/toeplitz-matrix/",
      "difficulty": "Easy"
    },
    "topics": [
      "Matrix Diagonal"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Check if matrix is symmetric:\n\n1. First check if matrix is square (m == n)\n2. Compare element at [i][j] with element at [j][i]\n3. If any pair doesn't match, not symmetric\n4. If all pairs match, it's symmetric\n\nKey Points:\n- Must be square matrix\n- A[i][j] must equal A[j][i] for all i, j\n- Only need to check upper or lower triangle",
          "code": "#include <stdio.h>\n#include <stdbool.h>\n\nint main() {\n    int m, n;\n    int mat[100][100];\n    \n    scanf(\"%d %d\", &m, &n);\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &mat[i][j]);\n        }\n    }\n    \n    bool isSymmetric = true;\n    \n    // Check if square\n    if (m != n) {\n        isSymmetric = false;\n    } else {\n        // Check symmetry\n        for (int i = 0; i < m && isSymmetric; i++) {\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] != mat[j][i]) {\n                    isSymmetric = false;\n                    break;\n                }\n            }\n        }\n    }\n    \n    printf(\"%s\\n\", isSymmetric ? \"Symmetric Matrix\" : \"Not a Symmetric Matrix\");\n    return 0;\n}",
          "timeComplexity": "O(n²)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Toeplitz Matrix - Video Solution",
          "link": "https://www.youtube.com/watch?v=r1Al6vVg2VQ"
        },
        {
          "type": "tutorial",
          "explanation": "Check if matrix is Toeplitz (every diagonal from top-left to bottom-right has same elements).\n\nApproach:\n1. For each element (except last row and column)\n2. Compare with element at (i+1, j+1)\n3. If any pair differs, return false\n4. If all match, return true\n\nKey Points:\n- Every diagonal has constant values\n- Check element with its bottom-right neighbor\n- Early termination on mismatch",
          "code": "class Solution {\npublic:\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        \n        for (int i = 0; i < m - 1; i++) {\n            for (int j = 0; j < n - 1; j++) {\n                if (matrix[i][j] != matrix[i + 1][j + 1]) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n};",
          "timeComplexity": "O(m × n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 13,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Boundary-to-Center Matrix Walk",
      "description": "Problem: You are given a rectangular matrix of integers. Starting from the outer boundary, traverse the matrix in a clockwise manner and continue moving inward layer by layer until all elements are visited.\n\nInput:\n- First line: two integers r and c representing the number of rows and columns\n- Next r lines: c integers each representing the matrix elements\n\nOutput:\n- Print all visited elements in the order of traversal, separated by spaces\n\nExample:\nInput:\n3 3\n1 2 3\n4 5 6\n7 8 9\n\nOutput:\n1 2 3 6 9 8 7 4 5\n\nExplanation:\nThe traversal begins along the top row, proceeds down the rightmost column, then moves across the bottom row in reverse, and finally goes up the leftmost column. The same pattern repeats for the inner submatrix.\n\nTest Cases:\n\nTest Case 1:\nInput:\n2 3\n1 2 3\n4 5 6\nOutput:\n1 2 3 6 5 4\n\nTest Case 2:\nInput:\n3 1\n7\n8\n9\nOutput:\n7 8 9"
    },
    "question2": {
      "name": "Spiral Matrix",
      "link": "https://leetcode.com/problems/spiral-matrix/",
      "difficulty": "Medium"
    },
    "topics": [
      "Matrix Spiral"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Traverse matrix in spiral order using boundaries:\n\n1. Maintain four boundaries: top, bottom, left, right\n2. Traverse top row (left to right)\n3. Traverse right column (top to bottom)\n4. Traverse bottom row (right to left) if exists\n5. Traverse left column (bottom to top) if exists\n6. Shrink boundaries and repeat\n\nKey Points:\n- Update boundaries after each direction\n- Check if boundaries are valid before traversing\n- Handle single row/column cases",
          "code": "#include <stdio.h>\n\nint main() {\n    int r, c;\n    int mat[100][100];\n    \n    scanf(\"%d %d\", &r, &c);\n    \n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            scanf(\"%d\", &mat[i][j]);\n        }\n    }\n    \n    int top = 0, bottom = r - 1, left = 0, right = c - 1;\n    \n    while (top <= bottom && left <= right) {\n        // Top row\n        for (int j = left; j <= right; j++) {\n            printf(\"%d \", mat[top][j]);\n        }\n        top++;\n        \n        // Right column\n        for (int i = top; i <= bottom; i++) {\n            printf(\"%d \", mat[i][right]);\n        }\n        right--;\n        \n        // Bottom row (if exists)\n        if (top <= bottom) {\n            for (int j = right; j >= left; j--) {\n                printf(\"%d \", mat[bottom][j]);\n            }\n            bottom--;\n        }\n        \n        // Left column (if exists)\n        if (left <= right) {\n            for (int i = bottom; i >= top; i--) {\n                printf(\"%d \", mat[i][left]);\n            }\n            left++;\n        }\n    }\n    \n    printf(\"\\n\");\n    return 0;\n}",
          "timeComplexity": "O(m × n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Spiral Matrix - Video Solution",
          "link": "https://www.youtube.com/watch?v=BJnMZNwUk1M"
        },
        {
          "type": "tutorial",
          "explanation": "Return all elements in spiral order.\n\nApproach:\n1. Use four boundary variables\n2. Traverse in order: right, down, left, up\n3. Shrink boundaries after each direction\n4. Continue until all elements visited\n\nKey Points:\n- Handle edge cases (empty, single row/column)\n- Check boundaries before each traversal\n- Use vector to store result",
          "code": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        vector<int> result;\n        if (matrix.empty()) return result;\n        \n        int top = 0, bottom = matrix.size() - 1;\n        int left = 0, right = matrix[0].size() - 1;\n        \n        while (top <= bottom && left <= right) {\n            for (int j = left; j <= right; j++) {\n                result.push_back(matrix[top][j]);\n            }\n            top++;\n            \n            for (int i = top; i <= bottom; i++) {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n            \n            if (top <= bottom) {\n                for (int j = right; j >= left; j--) {\n                    result.push_back(matrix[bottom][j]);\n                }\n                bottom--;\n            }\n            \n            if (left <= right) {\n                for (int i = bottom; i >= top; i--) {\n                    result.push_back(matrix[i][left]);\n                }\n                left++;\n            }\n        }\n        \n        return result;\n    }\n};",
          "timeComplexity": "O(m × n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 14,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Check Identity Matrix",
      "description": "Problem: Write a program to check whether a given square matrix is an Identity Matrix. An identity matrix is a square matrix in which all diagonal elements are 1 and all non-diagonal elements are 0.\n\nInput:\n- First line: integer n representing number of rows and columns\n- Next n lines: n integers each representing the matrix elements\n\nOutput:\n- Print \"Identity Matrix\" if the matrix satisfies the condition\n- Otherwise, print \"Not an Identity Matrix\"\n\nExample:\nInput:\n3\n1 0 0\n0 1 0\n0 0 1\n\nOutput:\nIdentity Matrix"
    },
    "question2": {
      "name": "Rotate Image",
      "link": "https://leetcode.com/problems/rotate-image/",
      "difficulty": "Medium"
    },
    "topics": [
      "Matrix Properties"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Check if matrix is identity matrix:\n\n1. Must be square matrix (n × n)\n2. Diagonal elements (i == j) must be 1\n3. Non-diagonal elements (i != j) must be 0\n4. Check all elements\n\nKey Points:\n- Identity matrix is always square\n- Diagonal: mat[i][i] = 1\n- Off-diagonal: mat[i][j] = 0 where i ≠ j",
          "code": "#include <stdio.h>\n#include <stdbool.h>\n\nint main() {\n    int n;\n    int mat[100][100];\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &mat[i][j]);\n        }\n    }\n    \n    bool isIdentity = true;\n    \n    for (int i = 0; i < n && isIdentity; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) {\n                if (mat[i][j] != 1) {\n                    isIdentity = false;\n                    break;\n                }\n            } else {\n                if (mat[i][j] != 0) {\n                    isIdentity = false;\n                    break;\n                }\n            }\n        }\n    }\n    \n    printf(\"%s\\n\", isIdentity ? \"Identity Matrix\" : \"Not an Identity Matrix\");\n    return 0;\n}",
          "timeComplexity": "O(n²)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Rotate Image - Video Solution",
          "link": "https://www.youtube.com/watch?v=fMSJSS7eO1w"
        },
        {
          "type": "tutorial",
          "explanation": "Rotate n×n matrix 90 degrees clockwise in-place.\n\nApproach:\n1. Transpose the matrix (swap mat[i][j] with mat[j][i])\n2. Reverse each row\n3. Result is 90-degree clockwise rotation\n\nAlternative: Rotate layer by layer\n\nKey Points:\n- In-place rotation required\n- Transpose + reverse = rotate 90°\n- Must handle square matrix only",
          "code": "class Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        \n        // Transpose\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n        \n        // Reverse each row\n        for (int i = 0; i < n; i++) {\n            reverse(matrix[i].begin(), matrix[i].end());\n        }\n    }\n};",
          "timeComplexity": "O(n²)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 15,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Matrix Diagonal Sum",
      "description": "Problem: Given a matrix, calculate the sum of its primary diagonal elements. The primary diagonal consists of elements where row index equals column index.\n\nInput:\n- First line: two integers m and n\n- Next m lines: n integers each\n\nOutput:\n- Print the sum of the primary diagonal elements\n\nExample:\nInput:\n3 3\n1 2 3\n4 5 6\n7 8 9\n\nOutput:\n15\n\nExplanation:\n1 + 5 + 9 = 15"
    },
    "question2": {
      "name": "Set Matrix Zeroes",
      "link": "https://leetcode.com/problems/set-matrix-zeroes/",
      "difficulty": "Medium"
    },
    "topics": [
      "Matrix"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Calculate sum of diagonal elements:\n\n1. Primary diagonal: elements where i == j\n2. Sum only these elements\n3. Works only for square matrices\n\nKey Points:\n- Diagonal elements: mat[0][0], mat[1][1], ..., mat[n-1][n-1]\n- For non-square matrix, min(m, n) diagonal elements\n- Can also calculate secondary diagonal (i + j == n - 1)",
          "code": "#include <stdio.h>\n\nint main() {\n    int m, n;\n    int mat[100][100];\n    \n    scanf(\"%d %d\", &m, &n);\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &mat[i][j]);\n        }\n    }\n    \n    int sum = 0;\n    int minDim = m < n ? m : n;\n    \n    for (int i = 0; i < minDim; i++) {\n        sum += mat[i][i];\n    }\n    \n    printf(\"%d\\n\", sum);\n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Set Matrix Zeroes - Video Solution",
          "link": "https://www.youtube.com/watch?v=T41rL0L3Pnw"
        },
        {
          "type": "tutorial",
          "explanation": "Set entire row and column to 0 if element is 0.\n\nApproach (O(1) space):\n1. Use first row and column as markers\n2. Scan matrix, mark first row/column if 0 found\n3. Use markers to set zeros\n4. Handle first row/column separately\n\nKey Points:\n- Must modify in-place\n- O(1) space solution uses matrix itself\n- Process from bottom-right to preserve markers",
          "code": "class Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        bool firstRow = false, firstCol = false;\n        \n        // Check if first row/col has zeros\n        for (int i = 0; i < m; i++) {\n            if (matrix[i][0] == 0) firstCol = true;\n        }\n        for (int j = 0; j < n; j++) {\n            if (matrix[0][j] == 0) firstRow = true;\n        }\n        \n        // Mark zeros in first row/col\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (matrix[i][j] == 0) {\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        \n        // Set zeros based on markers\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        \n        // Handle first row/col\n        if (firstRow) {\n            for (int j = 0; j < n; j++) matrix[0][j] = 0;\n        }\n        if (firstCol) {\n            for (int i = 0; i < m; i++) matrix[i][0] = 0;\n        }\n    }\n};",
          "timeComplexity": "O(m × n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 16,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Frequency Counter in Array",
      "description": "Problem: Given an array of integers, count the frequency of each distinct element and print the result.\n\nInput:\n- First line: integer n (size of array)\n- Second line: n integers\n\nOutput:\n- Print each element followed by its frequency in the format element:count\n\nExample:\nInput:\n5\n1 2 2 3 1\n\nOutput:\n1:2 2:2 3:1"
    },
    "question2": {
      "name": "Rotate Array",
      "link": "https://leetcode.com/problems/rotate-array/description/",
      "difficulty": "Easy"
    },
    "topics": [
      "Array Count",
      "HashMap Logic"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Count frequency of elements using hash map (or frequency array):\n\n1. Iterate through array\n2. For each element, increment its count in map\n3. Print all element-frequency pairs\n\nKey Points:\n- Use hash map for arbitrary values\n- Use frequency array if values in limited range\n- Maintains insertion order with ordered map",
          "code": "#include <stdio.h>\n\nint main() {\n    int n;\n    int arr[100];\n    int freq[1001] = {0}; // Assuming values 0-1000\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n        freq[arr[i]]++;\n    }\n    \n    // Print in order of first appearance\n    for (int i = 0; i < n; i++) {\n        if (freq[arr[i]] > 0) {\n            printf(\"%d:%d \", arr[i], freq[arr[i]]);\n            freq[arr[i]] = 0; // Mark as printed\n        }\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(k) where k is range of values"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Rotate Array - Video Solution",
          "link": "https://www.youtube.com/watch?v=BHr381Guz3Y"
        },
        {
          "type": "tutorial",
          "explanation": "Rotate array to right by k steps.\n\nApproach (Reverse Method):\n1. Reverse entire array\n2. Reverse first k elements\n3. Reverse remaining n-k elements\n\nAlternative: Use extra space to copy\n\nKey Points:\n- k can be > n, use k % n\n- In-place solution preferred\n- Three reverses achieve rotation",
          "code": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n = nums.size();\n        k = k % n;\n        \n        // Reverse entire array\n        reverse(nums.begin(), nums.end());\n        \n        // Reverse first k elements\n        reverse(nums.begin(), nums.begin() + k);\n        \n        // Reverse remaining elements\n        reverse(nums.begin() + k, nums.end());\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 17,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Find Maximum and Minimum Element",
      "description": "Problem: Write a program to find the maximum and minimum values present in a given array of integers.\n\nInput:\n- First line: integer n\n- Second line: n integers\n\nOutput:\n- Print the maximum and minimum elements\n\nExample:\nInput:\n6\n3 5 1 9 2 8\n\nOutput:\nMax: 9\nMin: 1"
    },
    "question2": {
      "name": "Maximum Subarray",
      "link": "https://leetcode.com/problems/maximum-subarray/",
      "difficulty": "Medium"
    },
    "topics": [
      "Kadane",
      "DP Intro"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Find max and min in array:\n\n1. Initialize max and min to first element\n2. Iterate through remaining elements\n3. Update max if current > max\n4. Update min if current < min\n\nKey Points:\n- Single pass through array\n- Can optimize with pairs comparison\n- Handle empty array edge case",
          "code": "#include <stdio.h>\n#include <limits.h>\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    int max = arr[0];\n    int min = arr[0];\n    \n    for (int i = 1; i < n; i++) {\n        if (arr[i] > max) max = arr[i];\n        if (arr[i] < min) min = arr[i];\n    }\n    \n    printf(\"Max: %d\\n\", max);\n    printf(\"Min: %d\\n\", min);\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Maximum Subarray - Video Solution",
          "link": "https://www.youtube.com/watch?v=5WZl3MMT0Eg"
        },
        {
          "type": "tutorial",
          "explanation": "Find maximum sum contiguous subarray (Kadane's Algorithm).\n\nApproach:\n1. Keep track of current sum and max sum\n2. Add current element to current sum\n3. If current sum < 0, reset to 0\n4. Update max sum at each step\n\nKey Points:\n- Dynamic programming approach\n- Linear time solution\n- Handle all negative numbers case",
          "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int maxSum = nums[0];\n        int currentSum = nums[0];\n        \n        for (int i = 1; i < nums.size(); i++) {\n            currentSum = max(nums[i], currentSum + nums[i]);\n            maxSum = max(maxSum, currentSum);\n        }\n        \n        return maxSum;\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 18,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Rotate Array by K Positions",
      "description": "Problem: Given an array of integers, rotate the array to the right by k positions.\n\nInput:\n- First line: integer n\n- Second line: n integers\n- Third line: integer k\n\nOutput:\n- Print the rotated array\n\nExample:\nInput:\n5\n1 2 3 4 5\n2\n\nOutput:\n4 5 1 2 3"
    },
    "question2": {
      "name": "Product of Array Except Self",
      "link": "https://leetcode.com/problems/product-of-array-except-self/",
      "difficulty": "Medium"
    },
    "topics": [
      "Prefix Suffix",
      "Array"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Rotate array right by k positions using reversal:\n\n1. Normalize k: k = k % n\n2. Reverse entire array\n3. Reverse first k elements\n4. Reverse remaining n-k elements\n\nKey Points:\n- In-place rotation\n- Handle k > n\n- Three reverses achieve rotation",
          "code": "#include <stdio.h>\n\nvoid reverse(int arr[], int start, int end) {\n    while (start < end) {\n        int temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n\nint main() {\n    int n, k;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    scanf(\"%d\", &k);\n    \n    k = k % n;\n    \n    reverse(arr, 0, n - 1);\n    reverse(arr, 0, k - 1);\n    reverse(arr, k, n - 1);\n    \n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", arr[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Product of Array Except Self - Video Solution",
          "link": "https://www.youtube.com/watch?v=bNvIQI2wAjk"
        },
        {
          "type": "tutorial",
          "explanation": "Calculate product of all elements except self without division.\n\nApproach:\n1. Calculate prefix products (product of all elements before i)\n2. Calculate suffix products (product of all elements after i)\n3. result[i] = prefix[i] * suffix[i]\n\nOptimized: Use result array to store prefix, then multiply by suffix in reverse\n\nKey Points:\n- Cannot use division\n- O(n) time, O(1) extra space (output doesn't count)\n- Two passes through array",
          "code": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> result(n, 1);\n        \n        // Calculate prefix products\n        int prefix = 1;\n        for (int i = 0; i < n; i++) {\n            result[i] = prefix;\n            prefix *= nums[i];\n        }\n        \n        // Multiply by suffix products\n        int suffix = 1;\n        for (int i = n - 1; i >= 0; i--) {\n            result[i] *= suffix;\n            suffix *= nums[i];\n        }\n        \n        return result;\n    }\n};",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 19,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Pair Sum Closest to Zero",
      "description": "Problem: Given an array of integers, find two elements whose sum is closest to zero.\n\nInput:\n- First line: integer n\n- Second line: n space-separated integers\n\nOutput:\n- Print the pair of elements whose sum is closest to zero\n\nExample:\nInput:\n5\n1 60 -10 70 -80\n\nOutput:\n-10 1\n\nExplanation: Among all possible pairs, the sum of -10 and 1 is -9, which is the closest to zero compared to other pairs."
    },
    "question2": {
      "name": "Maximum Sum Circular Subarray",
      "link": "https://leetcode.com/problems/maximum-sum-circular-subarray/description/",
      "difficulty": "Medium"
    },
    "topics": [
      "Two Pointers"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Find pair with sum closest to zero using two pointers:\n\n1. Sort the array\n2. Use two pointers: left at start, right at end\n3. Calculate sum, update minimum if closer to zero\n4. Move pointers based on sum (if negative, move left; if positive, move right)\n\nKey Points:\n- Sorting enables two-pointer approach\n- Track minimum absolute sum\n- O(n log n) due to sorting",
          "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint compare(const void* a, const void* b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    qsort(arr, n, sizeof(int), compare);\n    \n    int left = 0, right = n - 1;\n    int minSum = INT_MAX;\n    int resLeft = 0, resRight = 0;\n    \n    while (left < right) {\n        int sum = arr[left] + arr[right];\n        \n        if (abs(sum) < abs(minSum)) {\n            minSum = sum;\n            resLeft = arr[left];\n            resRight = arr[right];\n        }\n        \n        if (sum < 0) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    printf(\"%d %d\\n\", resLeft, resRight);\n    return 0;\n}",
          "timeComplexity": "O(n log n)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "Maximum Sum Circular Subarray - Video Solution",
          "link": "https://www.youtube.com/watch?v=fxT9KjakYPM"
        },
        {
          "type": "tutorial",
          "explanation": "Maximum Sum Circular Subarray using Kadane’s Algorithm.\n\nApproach:\n1. Use Kadane’s algorithm to find maximum subarray sum (non-circular).\n2. Use modified Kadane’s to find minimum subarray sum.\n3. Calculate total array sum.\n4. Answer = max(maxSub, totalSum - minSub).\n5. If all elements are negative (totalSum == minSub), return maxSub.",
          "code": "int maxSubarraySumCircular(int* nums, int numsSize) {\n    int totalSum = 0;\n    int maxSub = nums[0], currentMax = nums[0];\n    int minSub = nums[0], currentMin = nums[0];\n\n    for (int i = 0; i < numsSize; i++) {\n        totalSum += nums[i];\n        if (i > 0) {\n            currentMax = (nums[i] > currentMax + nums[i]) ? nums[i] : currentMax + nums[i];\n            maxSub = (maxSub > currentMax) ? maxSub : currentMax;\n\n            currentMin = (nums[i] < currentMin + nums[i]) ? nums[i] : currentMin + nums[i];\n            minSub = (minSub < currentMin) ? minSub : currentMin;\n        }\n    }\n\n    if (totalSum == minSub) return maxSub;\n\n    int circularMax = totalSum - minSub;\n    return (maxSub > circularMax) ? maxSub : circularMax;\n}",
          "timeComplexity": "O(n)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  },
  {
    "day": 20,
    "unit": "Unit I: Introduction",
    "question1": {
      "title": "Count Subarrays with Sum Zero",
      "description": "Problem: Given an array of integers, count the number of subarrays whose sum is equal to zero.\n\nInput:\n- First line: integer n\n- Second line: n integers\n\nOutput:\n- Print the count of subarrays having sum zero\n\nExample:\nInput:\n6\n1 -1 2 -2 3 -3\n\nOutput:\n6\n\nExplanation: A subarray is a continuous part of the array. For the input array 1 -1 2 -2 3 -3, the following subarrays have sum zero: [1, -1], [2, -2], [3, -3], [1, -1, 2, -2], [2, -2, 3, -3], and [1, -1, 2, -2, 3, -3]. Since there are 6 such subarrays, the output is 6."
    },
    "question2": {
      "name": "3Sum",
      "link": "https://leetcode.com/problems/3sum/",
      "difficulty": "Medium"
    },
    "topics": [
      "Sorting",
      "Two Pointers"
    ],
    "solutions": {
      "question1": [
        {
          "type": "tutorial",
          "explanation": "Count subarrays with sum zero using hash map:\n\n1. Use prefix sum approach\n2. Store cumulative sums in hash map with their frequencies\n3. If same prefix sum appears twice, subarrays between them have sum 0\n4. Count = frequency * (frequency - 1) / 2 for each sum\n\nKey Points:\n- Prefix sum concept\n- Hash map to track sums\n- Combination formula for counting",
          "code": "#include <stdio.h>\n\nint main() {\n    int n;\n    int arr[100];\n    \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    int count = 0;\n    \n    // Brute force: check all subarrays\n    for (int i = 0; i < n; i++) {\n        int sum = 0;\n        for (int j = i; j < n; j++) {\n            sum += arr[j];\n            if (sum == 0) {\n                count++;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", count);\n    return 0;\n}",
          "timeComplexity": "O(n²)",
          "spaceComplexity": "O(1)"
        }
      ],
      "question2": [
        {
          "type": "video",
          "label": "3Sum - Video Solution",
          "link": "https://www.youtube.com/watch?v=jzZsG8n2R9A"
        },
        {
          "type": "tutorial",
          "explanation": "Find all unique triplets that sum to zero.\n\nApproach:\n1. Sort the array\n2. Fix first element, use two pointers for remaining\n3. Skip duplicates to avoid duplicate triplets\n4. Adjust pointers based on sum\n\nKey Points:\n- Sort first for two-pointer technique\n- Handle duplicates carefully\n- O(n²) time complexity",
          "code": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int>> result;\n        sort(nums.begin(), nums.end());\n        \n        for (int i = 0; i < nums.size(); i++) {\n            if (i > 0 && nums[i] == nums[i-1]) continue;\n            \n            int left = i + 1, right = nums.size() - 1;\n            \n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                \n                if (sum == 0) {\n                    result.push_back({nums[i], nums[left], nums[right]});\n                    while (left < right && nums[left] == nums[left+1]) left++;\n                    while (left < right && nums[right] == nums[right-1]) right--;\n                    left++;\n                    right--;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        return result;\n    }\n};",
          "timeComplexity": "O(n²)",
          "spaceComplexity": "O(1)"
        }
      ]
    }
  }
]
